Docker
- Open-source platform that automates the deployment, scaling, and management of applications using containerization.
- In simple terms, Docker allows you to package an application and all its dependecies (libraries, frameworks, etc.) into a single container that can run consistently across different environments.

Core concepts:
1. Image: (blueprint for a container)
A lightweight, standalone, and executable package that includes everything needed to run a piece of software (code, runtime, libraries, environment variables, and config files). Images are read-only templates used to create containers.

2. Container: (running instance of an image)
Lightweight, portable environment where application runs.

3. Docker Engine:
The core component of Docker that runs on your host machine. It's a client server application with three main components:
 - Docker Daemon - background service that manages Docker objects (images, containers, networks, volumes) and handles container lifecycle.
 - Docker CLI - Command Line Interface that allows users to interact with Docker using commands.
 - REST API - An API that the CLI uses to communicate with the Docker Daemon.

4. Dockerfile:
A text file that contains a series of instructions on how to build a Docker image.

5. Docker Hub/Registry:
A cloud-based repository where Docker users can create, test, store, and distribute Docker images.

6. Docker compose:
A tool for defining and running multi-container Docker applications. It uses a YAML file to configure the application services.

7. Docker Volumes:
A way to persist data generated by and used by Docker containers. Volumes are stored outside the container's filesystem, making them ideal for data that needs to be retained across container restarts or removals.

8. Docker Network:
Allows containers to communicate with each other with the host machine.

Docker Commands:
1. Check images 
docker images

2. Check containers
will show all running containers
docker ps

will show all running/non-running containers
docker ps -a

3. Create image
docker build .

docker build -t mru-app-img .

4. Run the container
docker run -d -p 9898:9898 --name mru-container mru-app-img
-d = detach mode
-p = port forwarding

5. Remove the container
docker rm mru-container

- delete any container forcefully
docker rm mru-container -f

Bind mount volumes
- Right now the problem is that if we do any changes in our then it won't sync with Docker, so we have to rebuild the image

Anonymous volumes
Command for Mac
docker run -v $(pwd):/app -d -p 9898:9898 --name mru-container mru-app-img

For Windows:
docker run -v "${pwd}:/app" -d -p 9898:9898 --name mru-container mru-app-img

Remove the container
Rebuild image
Run container with -v flag

Now we want read only container
docker run -v $(pwd):/app:ro -d -p 9898:9898 --name mru-container mru-app-img

How do we pass environment variables
docker run -v $(pwd):/app:ro -d -p 9898:9797 --env PORT=9797 --name mru-container mru-app-img

What if we have multiple environment variables?
Solution is to use .env file

docker run -v $(pwd):/app:ro -d -p 9898:9797 --env-file ./.env --name mru-container mru-app-img

====================

Docker Compose
1. Because the command is now too complicated
2. What if we want to handle multiple containers

Run docker compose:
- docker compose up -d

Build image again
- docker compose up -d --build

Down docker compose
- docker compose down

- docker compose down -v
-v is for removing anonymous volumes

===============

Dev and Prod environment:
- first update package.json: install nodemon in dev environment
    - npm install nodemon --save-dev
- second update Dockerfile and add if else

ARG NODE_ENV
RUN if [ "${NODE_ENV}" = "development" ]; \
    then npm install; \
    else npm install --only=production; \
fi

- third update CMD in Dockerfile

Now let's execute docker with dev and prod environment

Dev environment
- docker compose -f docker-compose.yaml -f docker-compose.dev.yaml up -d

Down docker compose dev
- docker compose -f docker-compose.yaml -f docker-compose.dev.yaml down

Prod environment
- docker compose -f docker-compose.yaml -f docker-compose.prod.yaml up -d
